German protocol:

- check the way the TestScript was constructed
- why does it not terminate with /dfs:1 (or it doesn't seem to) ?

===========================================================================
DONE:
===========================================================================

- pretty printing of states. This is now only used for debugging purposes
  (not in comparisons or for storage), so there is no more need for a
  compressed state printing function. But:

  I also wrote a script for flattening (one-state-per-line), sorting, and
  unique-checking a pretty-printed stream of states. This is great for
  finding diffs in sets of states.

- abstract execution: now respects receive and defer sets. That is,
  not only head events can be dequeued, but also "later" events if the
  head event is not dequeable.

  Instead of duplicating the code for stepping a PrtImplMachine, I iterate
  through all events in the queue and set the environment up so that this
  event and this event only is dequeued (by putting it at the head). This
  tells me whether the event is dequeable, and it tells me what gets
  modified in the state machine other than the queue, i.e. the "local"
  variables. I uses these modifications and then only adjust the queue, to
  simulate a proper global execution step.

- made an extensible toy example, for incremental feature addition

- [technical] found out how to circumvent the recurring permission
  problems: during git commit, during git push, even during building. We
  suspected at some time that this is due to my mixed use of Cygwin and
  Windows file access. So I used cygwin in read-only mode (for things like
  grep and diff). That helped, but sometimes the problem still recurred.

  I then noticed that starting the Developer Command Prompt for VS
  as Administrator solved all problems. Not sure that this sledge-hammer
  solution is really the way to go, but it works.

- made a specific example for stuttering. It works (it stutters 1 step
  later than it "should", due to the extra information that a state keeps
  around?).

  To do:

  * if unsuccessful: why exactly it does not stutter earlier, i.e. what
    distinguishes the earlier states?

    Found that the difference visible-04 -> visible-05 was the addition of two visible states.
    These two new states were almost identical. Difference:

    continuation:     Return,null,False,null vs.
                      Return,null,False,Main(1)

    nextSMOperation:  ExecuteFunctionOperation vs.
                      DequeueOperation

  * should we really use the complete "local" state info for abstraction,
    or only the "fields" entry: this is the *semantic* information.
    There are many examples where there is a "semantic stutter",
    yet the complete local state vector differs, due to internal trackage.
    What about "null" (uninitialized) entries? There are many!

- added CheckFailure to all runs of StateMachine. When we encounter a
  PrtAssumeFailureException, we ignore this execution.  For all other
  failures, such as "failed to handle event", we stop and let the user fix
  this first.

  I came across this when I noticed that my machine produced invalid
  intermediate states due to not handling certain events. Since I did not
  catch "failed to handle event XYZ" exceptions, these intermediate states
  were treated as valid and caused the algorithm to fail to terminate.

  Now the algorithm will abort unless the system is "responsive", which I
  understand to mean: for every state S and every event E, S must either
  handle E or DEFER E.

- I also added a simple facility to introduce STATE INVARIANTS. The Stutter
  example, for instance, can be proved correct using SET ABSTRACTION with
  two simple state invariants,

  (Currently the invariant specification is not user friendly, but that can
  easily be improved.)
