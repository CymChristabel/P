===========================================================================
DONE:
===========================================================================

- Implemented empty-tail abstraction. This keeps ZERO info about the tail
  of the queue, only the head. It worked, but poorly: needed to add a lot
  of invariants to make it converge, and only reduces the number of reached
  visible states slightly. For STUTTER it did not reduce the cutoff size at all.

  I currently do not maintain it.

- abstract execution: now respects receive and defer sets. That is,
  not only head events can be dequeued, but also "later" events if the
  head event is not dequeueable.

  Instead of duplicating the code for stepping a PrtImplMachine, I iterate
  through all events in the tail and set the environment up so that this
  event and this event only is dequeued, by putting it at the head of the
  otherwise empty queue. This tells me whether the event is dequeueable,
  and it tells me what gets modified in the state machine other than the
  queue, i.e. the "local" variables. I use these modifications and then
  only adjust the queue, to simulate a proper global execution step.

  I also rewrote the enqueue method for the case of abstract states: they
  enqueue differently than concrete states!

  Updates to local variables (everything but the queues) are unaffected.

- added CheckFailure to all runs of StateMachine. When we encounter a
  PrtAssumeFailureException, we ignore this execution.  For all other
  failures, such as "failed to handle event", we stop and let the user fix
  this first.

  I came across this when I noticed that my machine produced invalid
  intermediate states due to not handling certain events. Since I did not
  catch "failed to handle event XYZ" exceptions, these intermediate states
  were treated as valid and caused the algorithm to fail to terminate.

  Now the algorithm will abort unless the system is "responsive", which I
  understand to mean: for every state S and every event E, S must either
  handle E or DEFER E.

- made a specific example for stuttering. It turns out it doesn't actually
  stutter, and it plateaus later than it "should", due to extra trackage.

  I haven't really found an example that stutters ...

- I also added a simple facility to introduce STATE and TRANSITION
  INVARIANTS. The Stutter example, for instance, can be proved correct
  using TAIL-LIST abstraction with one simple state invariant.

  (Currently the invariant specification is not user friendly, but that can
  easily be improved.)

- pretty printing of states. This is now used only for debugging purposes
  (not in comparisons or for storage), so there is no more need for a
  compressed state printing function. But:

  I also wrote a script for flattening (one-state-per-line), sorting, and
  unique-checking a pretty-printed stream of states. This is great for
  finding diffs in sets of states.

- [technical] found out how to circumvent the recurring permission
  problems: during git commit, during git push, even during building. We
  suspected at some time that this is due to my mixed use of Cygwin and
  Windows file access. So I used cygwin in read-only mode (for things like
  grep and diff). That helped, but sometimes the problem still recurred.

  I then noticed that starting the Developer Command Prompt for VS
  as Administrator solved all problems. Not sure that this sledge-hammer
  solution is really the way to go, but it works.

===========================================================================

- implemented list abstraction: all queue elements are stored in a list
  that stores elements in their order of first occurrence. Future
  occurrences are dropped. Compared to a set representation, this has the
  advantage that I know exactly what the first dequeuable event is. Once
  found, we can stop searching for a dequeuable event.

  In fact, I don't have to search for dequeuable events at all, rather just
  let the run method take care of it. For this method, the list abstraction
  is just like a regular queue, which happens to have no duplicates. The
  first event it dequeues is the first event that would have been dequeued
  in the concrete world.

  This greatly simplifies implementation.

  Downsides are that this higher precision must be maintained in the
  abstract successor computation, and that there are now some abstract
  successors that are inconsistent but abstractly reachable and need to be
  removed via lemmas. Example: (PING,WAIT) in the Stutter protocol.

My conclusions about what abstraction to use are as follows.

- the empty-tail abstraction is too weak. I am not considering it.

- I am using both queue-set and queue-list abstractions. It seems difficult
  to tell which one is better in general. Higher precision can make some
  decisions easier, but may be harder to maintain, and may generate more
  false positives that have to be ruled out by lemmas.

  For inststance, for the Stutter protocol I needed different sets of
  lemmas to rule out the (few) inconsistent abstract successor states.

- An orthogonal consideration is whether to store the whole queue in a
  single data structure (list or set), or whether to keep the head
  separately. It turns out that for the P language, this is not useful,
  since we anyway dequeue the first event that we find to be dequeuable,
  head or not.

  It is, however, possible to keep a prefix of fixed-length l of the queue
  precisely in the abstraction, and truly abstract only the rest. Now, if
  l=1, we happen to keep the head separate, but it might equally well be
  the first two queue elements. There is nothing special about the head.

In summary, it makes sense to offer both queue-list and queue-set
abstractions, possibly with concrete-prefix length parameter l (default: 0).

===========================================================================

Implemented a facility to investigate an unreachable abstract successor
state, identified by its hash value. This facility re-runs the analysis and
specifically looks out for when this successor is encountered. It then
pretty-prints this state and its predecessor.
